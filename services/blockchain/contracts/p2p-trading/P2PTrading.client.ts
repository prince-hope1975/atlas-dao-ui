/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.25.2.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Addr, Timestamp, Uint64, AssetInfo, Uint128, TradeState, AllCounterTradesResponse, TradeResponse, TradeInfoResponse, CounterTradeInfo, AdditionalTradeInfoResponse, Comment, Sg721Token, Cw721Coin, Coin, AllTradesResponse, ExecuteMsg, AddAssetAction, InstantiateMsg, QueryMsg, QueryFilters } from "./P2PTrading.types";
export interface P2PTradingReadOnlyInterface {
  contractAddress: string;
  contractInfo: () => Promise<ContractInfoResponse>;
  tradeInfo: ({
    tradeId
  }: {
    tradeId: number;
  }) => Promise<TradeInfoResponse>;
  counterTradeInfo: ({
    counterId,
    tradeId
  }: {
    counterId: number;
    tradeId: number;
  }) => Promise<CounterTradeInfoResponse>;
  getAllTrades: ({
    filters,
    limit,
    startAfter
  }: {
    filters?: QueryFilters;
    limit?: number;
    startAfter?: number;
  }) => Promise<GetAllTradesResponse>;
  getCounterTrades: ({
    filters,
    limit,
    startAfter,
    tradeId
  }: {
    filters?: QueryFilters;
    limit?: number;
    startAfter?: number;
    tradeId: number;
  }) => Promise<GetCounterTradesResponse>;
  getAllCounterTrades: ({
    filters,
    limit,
    startAfter
  }: {
    filters?: QueryFilters;
    limit?: number;
    startAfter?: CounterTradeInfo;
  }) => Promise<GetAllCounterTradesResponse>;
}
export class P2PTradingQueryClient implements P2PTradingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.contractInfo = this.contractInfo.bind(this);
    this.tradeInfo = this.tradeInfo.bind(this);
    this.counterTradeInfo = this.counterTradeInfo.bind(this);
    this.getAllTrades = this.getAllTrades.bind(this);
    this.getCounterTrades = this.getCounterTrades.bind(this);
    this.getAllCounterTrades = this.getAllCounterTrades.bind(this);
  }

  contractInfo = async (): Promise<ContractInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_info: {}
    });
  };
  tradeInfo = async ({
    tradeId
  }: {
    tradeId: number;
  }): Promise<TradeInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      trade_info: {
        trade_id: tradeId
      }
    });
  };
  counterTradeInfo = async ({
    counterId,
    tradeId
  }: {
    counterId: number;
    tradeId: number;
  }): Promise<CounterTradeInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      counter_trade_info: {
        counter_id: counterId,
        trade_id: tradeId
      }
    });
  };
  getAllTrades = async ({
    filters,
    limit,
    startAfter
  }: {
    filters?: QueryFilters;
    limit?: number;
    startAfter?: number;
  }): Promise<GetAllTradesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_trades: {
        filters,
        limit,
        start_after: startAfter
      }
    });
  };
  getCounterTrades = async ({
    filters,
    limit,
    startAfter,
    tradeId
  }: {
    filters?: QueryFilters;
    limit?: number;
    startAfter?: number;
    tradeId: number;
  }): Promise<GetCounterTradesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_counter_trades: {
        filters,
        limit,
        start_after: startAfter,
        trade_id: tradeId
      }
    });
  };
  getAllCounterTrades = async ({
    filters,
    limit,
    startAfter
  }: {
    filters?: QueryFilters;
    limit?: number;
    startAfter?: CounterTradeInfo;
  }): Promise<GetAllCounterTradesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_counter_trades: {
        filters,
        limit,
        start_after: startAfter
      }
    });
  };
}
export interface P2PTradingInterface extends P2PTradingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  createTrade: ({
    comment,
    whitelistedUsers
  }: {
    comment?: string;
    whitelistedUsers?: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addAsset: ({
    action,
    asset
  }: {
    action: AddAssetAction;
    asset: AssetInfo;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removeAssets: ({
    assets,
    counterId,
    tradeId
  }: {
    assets: number[][];
    counterId?: number;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addWhitelistedUsers: ({
    tradeId,
    whitelistedUsers
  }: {
    tradeId: number;
    whitelistedUsers: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removeWhitelistedUsers: ({
    tradeId,
    whitelistedUsers
  }: {
    tradeId: number;
    whitelistedUsers: string[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setComment: ({
    comment,
    counterId,
    tradeId
  }: {
    comment: string;
    counterId?: number;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addNFTsWanted: ({
    nftsWanted,
    tradeId
  }: {
    nftsWanted: string[];
    tradeId?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removeNFTsWanted: ({
    nftsWanted,
    tradeId
  }: {
    nftsWanted: string[];
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setNFTsWanted: ({
    nftsWanted,
    tradeId
  }: {
    nftsWanted: string[];
    tradeId?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  flushNFTsWanted: ({
    tradeId
  }: {
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  addTokensWanted: ({
    tokensWanted,
    tradeId
  }: {
    tokensWanted: AssetInfo[];
    tradeId?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  removeTokensWanted: ({
    tokensWanted,
    tradeId
  }: {
    tokensWanted: AssetInfo[];
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setTokensWanted: ({
    tokensWanted,
    tradeId
  }: {
    tokensWanted: AssetInfo[];
    tradeId?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  flushTokensWanted: ({
    tradeId
  }: {
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setTradePreview: ({
    action,
    asset
  }: {
    action: AddAssetAction;
    asset: AssetInfo;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  confirmTrade: ({
    tradeId
  }: {
    tradeId?: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  suggestCounterTrade: ({
    comment,
    tradeId
  }: {
    comment?: string;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  confirmCounterTrade: ({
    counterId,
    tradeId
  }: {
    counterId?: number;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  acceptTrade: ({
    comment,
    counterId,
    tradeId
  }: {
    comment?: string;
    counterId: number;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  cancelTrade: ({
    tradeId
  }: {
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  cancelCounterTrade: ({
    counterId,
    tradeId
  }: {
    counterId: number;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  refuseCounterTrade: ({
    counterId,
    tradeId
  }: {
    counterId: number;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  reviewCounterTrade: ({
    comment,
    counterId,
    tradeId
  }: {
    comment?: string;
    counterId: number;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawPendingAssets: ({
    tradeId,
    trader
  }: {
    tradeId: number;
    trader: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawAllFromTrade: ({
    tradeId
  }: {
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawAllFromCounter: ({
    counterId,
    tradeId
  }: {
    counterId: number;
    tradeId: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setNewOwner: ({
    owner
  }: {
    owner: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  setNewFeeContract: ({
    feeContract
  }: {
    feeContract: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class P2PTradingClient extends P2PTradingQueryClient implements P2PTradingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.createTrade = this.createTrade.bind(this);
    this.addAsset = this.addAsset.bind(this);
    this.removeAssets = this.removeAssets.bind(this);
    this.addWhitelistedUsers = this.addWhitelistedUsers.bind(this);
    this.removeWhitelistedUsers = this.removeWhitelistedUsers.bind(this);
    this.setComment = this.setComment.bind(this);
    this.addNFTsWanted = this.addNFTsWanted.bind(this);
    this.removeNFTsWanted = this.removeNFTsWanted.bind(this);
    this.setNFTsWanted = this.setNFTsWanted.bind(this);
    this.flushNFTsWanted = this.flushNFTsWanted.bind(this);
    this.addTokensWanted = this.addTokensWanted.bind(this);
    this.removeTokensWanted = this.removeTokensWanted.bind(this);
    this.setTokensWanted = this.setTokensWanted.bind(this);
    this.flushTokensWanted = this.flushTokensWanted.bind(this);
    this.setTradePreview = this.setTradePreview.bind(this);
    this.confirmTrade = this.confirmTrade.bind(this);
    this.suggestCounterTrade = this.suggestCounterTrade.bind(this);
    this.confirmCounterTrade = this.confirmCounterTrade.bind(this);
    this.acceptTrade = this.acceptTrade.bind(this);
    this.cancelTrade = this.cancelTrade.bind(this);
    this.cancelCounterTrade = this.cancelCounterTrade.bind(this);
    this.refuseCounterTrade = this.refuseCounterTrade.bind(this);
    this.reviewCounterTrade = this.reviewCounterTrade.bind(this);
    this.withdrawPendingAssets = this.withdrawPendingAssets.bind(this);
    this.withdrawAllFromTrade = this.withdrawAllFromTrade.bind(this);
    this.withdrawAllFromCounter = this.withdrawAllFromCounter.bind(this);
    this.setNewOwner = this.setNewOwner.bind(this);
    this.setNewFeeContract = this.setNewFeeContract.bind(this);
  }

  createTrade = async ({
    comment,
    whitelistedUsers
  }: {
    comment?: string;
    whitelistedUsers?: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_trade: {
        comment,
        whitelisted_users: whitelistedUsers
      }
    }, fee, memo, funds);
  };
  addAsset = async ({
    action,
    asset
  }: {
    action: AddAssetAction;
    asset: AssetInfo;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_asset: {
        action,
        asset
      }
    }, fee, memo, funds);
  };
  removeAssets = async ({
    assets,
    counterId,
    tradeId
  }: {
    assets: number[][];
    counterId?: number;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_assets: {
        assets,
        counter_id: counterId,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  addWhitelistedUsers = async ({
    tradeId,
    whitelistedUsers
  }: {
    tradeId: number;
    whitelistedUsers: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_whitelisted_users: {
        trade_id: tradeId,
        whitelisted_users: whitelistedUsers
      }
    }, fee, memo, funds);
  };
  removeWhitelistedUsers = async ({
    tradeId,
    whitelistedUsers
  }: {
    tradeId: number;
    whitelistedUsers: string[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_whitelisted_users: {
        trade_id: tradeId,
        whitelisted_users: whitelistedUsers
      }
    }, fee, memo, funds);
  };
  setComment = async ({
    comment,
    counterId,
    tradeId
  }: {
    comment: string;
    counterId?: number;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_comment: {
        comment,
        counter_id: counterId,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  addNFTsWanted = async ({
    nftsWanted,
    tradeId
  }: {
    nftsWanted: string[];
    tradeId?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_n_f_ts_wanted: {
        nfts_wanted: nftsWanted,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  removeNFTsWanted = async ({
    nftsWanted,
    tradeId
  }: {
    nftsWanted: string[];
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_n_f_ts_wanted: {
        nfts_wanted: nftsWanted,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  setNFTsWanted = async ({
    nftsWanted,
    tradeId
  }: {
    nftsWanted: string[];
    tradeId?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_n_f_ts_wanted: {
        nfts_wanted: nftsWanted,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  flushNFTsWanted = async ({
    tradeId
  }: {
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      flush_n_f_ts_wanted: {
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  addTokensWanted = async ({
    tokensWanted,
    tradeId
  }: {
    tokensWanted: AssetInfo[];
    tradeId?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_tokens_wanted: {
        tokens_wanted: tokensWanted,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  removeTokensWanted = async ({
    tokensWanted,
    tradeId
  }: {
    tokensWanted: AssetInfo[];
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_tokens_wanted: {
        tokens_wanted: tokensWanted,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  setTokensWanted = async ({
    tokensWanted,
    tradeId
  }: {
    tokensWanted: AssetInfo[];
    tradeId?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_tokens_wanted: {
        tokens_wanted: tokensWanted,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  flushTokensWanted = async ({
    tradeId
  }: {
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      flush_tokens_wanted: {
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  setTradePreview = async ({
    action,
    asset
  }: {
    action: AddAssetAction;
    asset: AssetInfo;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_trade_preview: {
        action,
        asset
      }
    }, fee, memo, funds);
  };
  confirmTrade = async ({
    tradeId
  }: {
    tradeId?: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      confirm_trade: {
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  suggestCounterTrade = async ({
    comment,
    tradeId
  }: {
    comment?: string;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      suggest_counter_trade: {
        comment,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  confirmCounterTrade = async ({
    counterId,
    tradeId
  }: {
    counterId?: number;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      confirm_counter_trade: {
        counter_id: counterId,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  acceptTrade = async ({
    comment,
    counterId,
    tradeId
  }: {
    comment?: string;
    counterId: number;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      accept_trade: {
        comment,
        counter_id: counterId,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  cancelTrade = async ({
    tradeId
  }: {
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_trade: {
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  cancelCounterTrade = async ({
    counterId,
    tradeId
  }: {
    counterId: number;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_counter_trade: {
        counter_id: counterId,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  refuseCounterTrade = async ({
    counterId,
    tradeId
  }: {
    counterId: number;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      refuse_counter_trade: {
        counter_id: counterId,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  reviewCounterTrade = async ({
    comment,
    counterId,
    tradeId
  }: {
    comment?: string;
    counterId: number;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      review_counter_trade: {
        comment,
        counter_id: counterId,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  withdrawPendingAssets = async ({
    tradeId,
    trader
  }: {
    tradeId: number;
    trader: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_pending_assets: {
        trade_id: tradeId,
        trader
      }
    }, fee, memo, funds);
  };
  withdrawAllFromTrade = async ({
    tradeId
  }: {
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_all_from_trade: {
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  withdrawAllFromCounter = async ({
    counterId,
    tradeId
  }: {
    counterId: number;
    tradeId: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_all_from_counter: {
        counter_id: counterId,
        trade_id: tradeId
      }
    }, fee, memo, funds);
  };
  setNewOwner = async ({
    owner
  }: {
    owner: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_new_owner: {
        owner
      }
    }, fee, memo, funds);
  };
  setNewFeeContract = async ({
    feeContract
  }: {
    feeContract: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_new_fee_contract: {
        fee_contract: feeContract
      }
    }, fee, memo, funds);
  };
}